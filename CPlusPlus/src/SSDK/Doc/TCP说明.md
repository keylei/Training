# TCP常见问题
- **Q**：为什么我发起了异步操作，如连接或者写，对方都没有反应，好像没有收到连接请求或者没有收到数据？ 
- **A**：一个很可能的原因是io_service在异步操作发起之后没有run，解决办法是保持io_service run。



- **Q**：为什么发送数据会报错？
- **A**：一个可能的原因是发送的数据失效了，异步发送要求发送的数据在回调完成之前都有效，异步操作只是将异步事件句柄投递到io_service队列中就返回了，并不是阻塞的，不注意这一点，如果是临时变量的数据，出了作用域就失效了，导致异步事件还没完成时数据就失效了。解决办法，保证发送数据在事件完成之前一直有效


- **Q**:为什么监听socket时，会报“函数不正确”的异常？
- **A**:因为监听时，也要保证这个socket一直有效，如果是一个临时变量socket，在调用异步监听后超出作用域就失效了，解决办法，将监听的socket保存起来，使它的生命周期和acceptor一样长


- **Q**:为什么连续调用异步操作时会报错?
- **A**:因为异步操作必须保证当前异步操作完成之后再发起下一次异步操作。解决办法：在异步完成事件处理完成之后再发起新的异步操作即可。


- **Q**:为什么对方半天收不到数据，过了半天才一下子收到之前发送的数据
- **A**:因为socket是流数据，一次发送多少数据不是外界能控制的，这也是所谓的粘包问题。解决办法，可以在接收时指定至少收多少的条件，或者做tcp分包处理。


# TCP的结构说明：

### 1.SSDK
**DataConverter**：主要负责数据类型的转化，在TCP中，需要其他类型和char类型的相互转化，会调用到这里的函数

### 2.SSDK/ASIO
**AsioCommon**：定义在ASIO模块中公用的接口

### 3.SSDK/ASIO/TCP
**Connection**：代表了一个远程的连接，即客户端，一个客户端同时只能连接一个服务端，但是一个服务端能够同时连接多个客户端，需要制定服务器的IP和端口号

**Server**：代表一个服务端，能够监听主机的一个端口

**RWHandler**：保存了客户端和服务端通用的读写接口，所以在客户端和服务端都可以调用RWHandler，
            它抽象了公共的读写行为
           
            
**Message**：缓存需要发送的数据，目前都是char型的，如果要涉及到别的类型传送，需要进行类型转化


# 异步和同步：

==目前模块中异步发送没有经过严格的测试，暂时不要调用！==


## 0.异步操作的思想：
用户发起异步事件，==asio将这些异步事件投递到一个队列中,用户发起的操作就返回了==，io_service::run会处理异步事件队列中的所有的异步事件，它会将这些事件交给操作系统处理，操作系统处理完成之后会丢到asio的事件完成的队列中，i==o_service发现有完成队列中有完成事件了，就会通知用户处理完成事件==。 所以用户要发起一个异步操作需要做三件事：

1. 调用asio异步操作接口，发起异步操作；如：async_connect、async_read、async_write，这些异步接口需要一个回调函数入参，这个回调函数在事件完成时，由io_service触发。

2. 调用io_service::run处理异步事件；==发起一个异步操作，必须要保证io_service::run==，因为io_service通过一个循环去处理这些异步操作事件的，如果没有事件就会退出，所以要保证异步事件发起之后，io_service::run还在运行。==要保证一直run的一个简单办法就是使用io_service::work，它可以保证io_service一直run==

3.  处理异步操作完成事件；在调用异步接口时会传入一个回调函数，这个回调函数就是处理操作完成事件的，比如读完成了，用户需要对这些数据进行业务逻辑的处理



## 1.asio异步发送复杂的地方在于: 


不能连续调用异步发送接口async_write，因为async_write内部是不断调用async_write_some，直到所有的数据发送完成为止。由于async_write调用之后就直接返回了，如果第一次调用async_write发送一个较大的包时，马上又再调用async_write发送一个很小的包时，有可能这时第一次的async_write还在循环调用async_write_some发送，而第二次的async_write要发送的数据很小，一下子就发出去了，这使得第一次发送的数据和第二次发送的数据交织在一起了，导致发送乱序的问题。

　
## 2.项目中解决异步发送的思路：
当用户发送数据时，不直接调用异步发送接口，而是将数据放到一个发送队列中，异步发送接口会循环从队列中取数据发送。循环发送过程的一个细节需要注意，用户发送数据时，如果发送队列为空时，说明异步发送已经将队列中所有的数据都发送完了，也意味着循环发送结束了，这时，需要在数据入队列之后再调用一下async_write重新发起异步循环发送。
　
　
## 3.异步发送存在的隐患　
　可以看到，异步发送比异步接收等其他异步操作更复杂，需要一个发送队列来保证发送不会乱序。但是，还有一个问题需要注意就是这个发送队列是没有加限制的，如果接收端收到数据之后阻塞处理，而发送又很快的话，就会导致发送队列的内存快速增长甚至内存爆掉。解决办法有两个：

- 发慢一点，并且保证接收端不会长时间阻塞socket；
- 控制发送队列的上限。
　　

第一种方法对实际应用的约束性较强，实际可操作性不高。第二种方法需要控制队列上限，不可避免的要加锁，这样就丧失了单线程异步发送的性能优势。所以建议用同步发送接口来发送数据，一来不用发送队列，自然也不会有内存暴涨的问题，二来也不会有复杂的循环发送过程，而且还可以通过线程池来提高发送效率。

## 4.总结：

- 不要连续发起异步发送，要等上次发送完成之后再发起下一个异步发送；
- 要考虑异步发送的发送队列内存可能会暴涨的问题；
- 相比复杂的异步发送，同步发送简单可靠，推荐优先使用同步发送接口

