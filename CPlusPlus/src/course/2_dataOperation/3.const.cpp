//#include <iostream>
//#include <string.h>

//using namespace std;

//////参数指针指向的内容为常量
////void setInfo(const char* info)
////{
////    //×  编译不通过，不能修改info的内容
////      strcpy(info,"context changed!");
////}

////void setInfo(char* const info)
////{
////    info = new char[6];
////}

////void setInfo(const string& info)
////{
////    info = "context changed!";
////}

//class SDK
//{

//};

//class Student
//{
//public:

//    Student(std::string& name):m_id(-1)//√  在构造函数中使用初始化列表初始化
//    {
//        this->m_name = name;
//        m_pGrade = new int[2]{1,2};
//        //        this->m_id = 2;//×  编译不通过
//    }

//    const string& name(){return this->m_name;}
//    const int*  gradeArr(){return this->m_pGrade;}


//    void print() const
//    {
//        cout << this->m_name << endl;

//        /*×  编译不通过，const后置修饰的成员函数不能修改成
//        员变量*/
//        //        this->m_pGrade = 0;

//        /*×  编译不通过，const后置修饰的成员函数不能调用非
//        const的成员函数*/
//        //        gradeArr();
//    }

//private:
//    string m_name;
//    int* m_pGrade { nullptr };

//    //    该成员变量只能类内初始化或者构造函数中使用初始化列表初始化。
//    const int m_id;
//};

//int main()
//{
//    //>>>----------------------------------------------------------------------------------------------------------
//    //1. 修饰局部变量

//    //    使用const定义局部变量，表示变量不可变，可以避免在函数中对某些不应修改的变量造成
//    //    可能的改动。该变量必须在声明的时候就进行初始化

//    //    //const 变量必须初始化，否则会编译通不过
//    //    const int pi = 3.14159;
//    //    //可以这样初始化，编译通过
//    //    const int temp = pi+1;
//    //    //×  编译失败，不可以修改常量的值
//    //    temp++;

//    //>>>----------------------------------------------------------------------------------------------------------
//    //2. 修饰指针
//    //    指针可以被修饰为常量。const修饰指针时既可以用来修饰指针指向的内容，
//    //    也可以用来修饰指针地址本身。主要有以下3种情况:

//    //    1.指向常量实例，不能修改被指向的对象,但可以使指针指向其它对象。
//    //    int value{5};
//    //    const int* pValue{&value};
//    //    //×  编译不通过，不能修改指针指向对象的值
//    ////    *pValue = 6;
//    //    //√  指向的地址可以修改
//    //    pValue = nullptr;

//    //2.指向常量指针，不能修改地址，但是可以修改指针对象的对象。
//    //    int value{5};
//    //    int* const pValue{&value};
//    //    *pValue = 6;//√  编译通过，能修改指针指向对象的值
//    //    pValue = nullptr;//×  编译不通过，不能修改地址

//    //3.指针和实例都定义为常量,都不能修改
//    //    int value{5};
//    //    const int* const pValue{&value};
//    //    *pValue = 6;//×  编译不通过，不能修改指针指向对象的值
//    //    pValue = nullptr;//×  编译不通过，不能修改地址

//    //>>>----------------------------------------------------------------------------------------------------------
//    // 3. 修饰引用
//    //    const还可以用来修饰引用。const放在类型前面和后面效果一样，都是表示引用不能被更新。
//    //    int const& value1{5};
//    //    const int& value2{5};

//    //    value1 = 6;//×  编译不通过，不能修改值
//    //    value2 = 6;//×  编译不通过，不能修改值

//    //注意: 引用一般在函数传递类对象又希望对对象进行保护的时候用到

//    //>>>----------------------------------------------------------------------------------------------------------
//    // 4.修饰函数参数

//    //>>>----------------------------------------------------------------------------------------------------------
//    //5.修饰函数返回值

//    //    使用const修饰函数返回值，返回值将不能修改，无论指针还是引用。
//    //    Student rime;
//    //    string& name = rime.name();
//    //    name = "keylei"; //编译不通过
//    //    cout << rime.name() <<endl;

//    //    auto pGrade = rime.gradeArr();
//    //    *pGrade = 2;
//    //     cout << *pGrade <<endl;

//    //>>>----------------------------------------------------------------------------------------------------------
//    //6.修饰成员变量

//    //>>>----------------------------------------------------------------------------------------------------------
//    //7.修饰成员函数

//    //    const 后置修饰的成员函数表示不允许在该函数内对它所在类的成员变量进行任何修改，
//    //    一旦这么做了，编译器就会弹出错误。同时它也不能调用没有被const修饰的成员函数。
//    //    string name("rime");
//    //    Student rime(name);
//    //    rime.print();

//    //>>>----------------------------------------------------------------------------------------------------------
//    //8.修饰常量对象
//    //    当一个对象声明为常量类型时，表示它的成员变量在其生命周期内不能修改，
//    //    同时该对象也只能调用其const的成员函数
//    //    string name("rime");
//    //    const Student rime(name);
//    //    rime.print();
//    //    rime.name();//调用非const函数, 将编译错误

//    return 0;
//}
