#include <stdio.h>
#include <time.h>

#include "datageneration.h"
#include "imagecompression.h"

//>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//图像压缩算法    //rime +1 这几个人相对算了版面整洁的
/**
 *  @brief  1.创建1000个float数组，长度从2048到5000随机生成，
 *            数据范围从0.00-5000.00随机生成
 *          2.遍历所有的数组,判断数组长度:
 *            如果长度>=4096,直接压缩;
 *            如果长度<4096,那么需要和其他长度小于<4096的数组压缩到到同一个的byte数组中,
 *            直到byte数组的元素个数>=4096,再压缩
 *
 *            byte数组需要设置表头,表头定义如下:
 *            a.数组中第1个元素：byte数组中压缩的float数组的个数
 *            b.数组中第2,3个byte：第一个数组的长度
 *            c.数组中第4,5个byte：第一个数组的最大值(整型)
 *            d.数组中第6,7个byte：第一个数组的最小值(整型)
 *            e.数组中往后n个byte：float数组每一个数据转化成一个byte
 *            f.如果存多个数据，依次往后按照步骤 b - e方式将数据存放到byte数组中
 *            备注:float数组中每一个小数部分去除,整数部分按照其最大值与最小值的范围
 *                映射到[0 - 255]
 *          3.将byte数组保存为文件,文件名按照压缩的元件名,如Byte只压缩一个数组,则文件名
 *            为"chip001",如果byte数组中压缩了多个数组,则文件名为"chip001_chip002"
 *          4.读取保存的文件,按照压缩的规则把高度从byte解析到float数组中
 *          5.计算压缩前数据与解压后数据的差值,并将每个数组的差值写入文件中,
 *            文件名以元件名加"_diff"组成,如chip001_diff
 *          6.计算压缩与解压的总时间,并在终端上显示
 *
 *  @author  bob
 *  @version 1.00 2017-11-06 bob
 */

//<<<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//定义全局变量
#define IMAGE_COUNT 1000                                // 图片的数量为1000
#define BLOCK_SIZE  4096                                // 单个区块的大小
#define FILE_DIR "./Data/"  //rime 目录就目录, 文件就文件, 这种命名说明啥
#define DATA_DIFF_DIR "./Data_Diff/"
#define PREFIX "chip"

//<<<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//rime 有些地方用arr, 用些地方用array
int main()
{
    //rime +1 版面比较干净, 不同region用了空行, 但是最好再加个标题
    //>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    //生成数据
    int arrayLenArr[IMAGE_COUNT];                      //数组的长度数组   //rime 就叫lenArr好了,没必要搞复杂
    //rime 要和下面的pRestorationArr对应, 下面既然加上了Restoration作为定语, 那么上面也需要进行对仗, 可以使用原始数据(orig)/需要压缩的数据(compressing)/生成的数据(generation)
    float * pHeightDataArr[IMAGE_COUNT];               //存储高度数据数组的头指针

    // 获取指定数量数组长度,并给每个数组的高度数据赋值
    generateHeightData(arrayLenArr,
                       IMAGE_COUNT,
                       pHeightDataArr);

    //>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    //>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    //压缩,解压数据
    //压缩数据并将压缩完的数据写入文件(文件名字以元件名称及数组索引号组成,如"chip001")
    //压缩数组中第一个元素记录压缩数组的个数,第2-7个元素记录表头(数组的长度,最大值,最小值) //rime+1 在调用的地方把用法都简单的说明了下, 注释尤其是关键逻辑的注释是不嫌多的
    compressDataAndExportToFile(pHeightDataArr,
                                arrayLenArr,
                                FILE_DIR,
                                IMAGE_COUNT,
                                PREFIX);

    float * pRestorationArr[IMAGE_COUNT];             //存储还原数据数组的头指针  //rime 既然大量用了decompression,这里就不需要再用Restoration
    //根据目录中读取文件中的byte数据,将其缓存到数组中
    //根据缓存数组数据,计算出数组长度,最大值,最小值
    //将数组中的数据解压至目标数组中
    importDataFromFileAndDecompress(pRestorationArr, FILE_DIR);//rime 上面的压缩加了宾语, 这里的解压为什么就没有了呢, 直接改成decompressFromFile
    //<<<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    //>>>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    //计算压缩前与解压后的数据差值,将其差值输出至指定路径的文件中
    float * pDiffArr[IMAGE_COUNT];                   //存储差值数据数组的头指针

    //计算压缩前与解压后数据的差值,并将数据存放到差值数组中
    calcDiff(pHeightDataArr,
                  pRestorationArr,
                  pDiffArr,
                  arrayLenArr,
                  IMAGE_COUNT);

    //输出结果至指定路径的文件
    exportFloatToFile(pDiffArr,
                      arrayLenArr,
                      IMAGE_COUNT,
                      DATA_DIFF_DIR,
                      PREFIX);
    //<<<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    for (int i = 0; i < IMAGE_COUNT; ++i)
    {
        free(pHeightDataArr[i]);       //释放存储原始数据数组的空间,并将其指针置为NULL
        free(pRestorationArr[i]);      //释放解压后数据数组的空间,并将其指针置为NULL
        free(pDiffArr[i]);             //释放差值数据数组的空间,并将其指针置为NULL
        pHeightDataArr[i] = NULL;
        pRestorationArr[i] = NULL;
        pDiffArr[i] = NULL;
    }
}
